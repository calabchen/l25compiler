package github.calabchen;

import java.util.ArrayList;

/**
 * 　　语法分析器。L25编译器中最重要的部分，在语法分析的过程中穿插着语法错误检查和目标代码生成。
 */
public class Parser {
    private Scanner lex;                    // 对词法分析器的引用
    private Table table;                    // 对符号表的引用
    private Interpreter interp;             // 对目标代码生成器的引用

    private final int symnum = Symbol.values().length;

    // 表示声明开始的符号集合、表示语句开始的符号集合、表示因子开始的符号集合
    // 实际上这就是声明、语句和因子的FIRST集合
    private SymSet declbegsys, statbegsys, facbegsys;

    /**
     * 当前符号，由nextsym()读入
     *
     * @see #nextSym()
     */
    private Symbol sym;

    /**
     * 当前作用域的堆栈帧大小，或者说数据大小（data size）
     */
    private int dx = 0;

    /**
     * 构造并初始化语法分析器，这里包含了C语言版本中init()函数的一部分代码
     *
     * @param l 编译器的词法分析器
     * @param t 编译器的符号表
     * @param i 编译器的目标代码生成器
     */
    public Parser(Scanner l, Table t, Interpreter i) {
        lex = l;
        table = t;
        interp = i;

        // 设置声明开始符号集
        declbegsys = new SymSet(symnum);
        declbegsys.set(Symbol.letsym);
        declbegsys.set(Symbol.funcsym);
        declbegsys.set(Symbol.mainsym);

        // 设置语句开始符号集
        statbegsys = new SymSet(symnum);
        statbegsys.set(Symbol.ident);
        statbegsys.set(Symbol.ifsym);
        statbegsys.set(Symbol.whilesym);
        statbegsys.set(Symbol.inputsym);
        statbegsys.set(Symbol.outputsym);
        statbegsys.set(Symbol.returnsym);

        // 设置因子开始符号集
        facbegsys = new SymSet(symnum);
        facbegsys.set(Symbol.ident);
        facbegsys.set(Symbol.number);
        facbegsys.set(Symbol.lparen);
    }

    /**
     * 启动语法分析过程，此前必须先调用一次nextsym()
     *
     * @see #nextSym()
     */
    public void parse() {
        SymSet nxtlev = new SymSet(symnum);
        nxtlev.or(declbegsys);
        nxtlev.or(statbegsys);

        parseProgram(0, nxtlev);
        if (sym != Symbol.eof)
            Err.report(20); // End of file expected
    }

    /**
     * 获得下一个语法符号，这里只是简单调用一下getsym()
     */
    public void nextSym() {
        lex.getsym();
        sym = lex.sym;
    }

    /**
     * 测试当前符号是否合法
     *
     * @param s1      我们需要的符号
     * @param s2      如果不是我们需要的，则需要一个补救用的集合
     * @param errcode 错误号
     */
    void test(SymSet s1, SymSet s2, int errcode) {
        // 在某一部分（如一条语句，一个表达式）将要结束时时我们希望下一个符号属于某集合
        //（该部分的后跟符号），test负责这项检测，并且负责当检测不通过时的补救措施，程
        // 序在需要检测时指定当前需要的符号集合和补救用的集合（如之前未完成部分的后跟符
        // 号），以及检测不通过时的错误号。
        if (!s1.get(sym)) {
            Err.report(errcode);
            // 当检测不通过时，不停获取符号，直到它属于需要的集合或补救的集合
            while (!s1.get(sym) && !s2.get(sym))
                nextSym();
        }
    }

    /**
     * 分析<主程序>
     */
    public void parseProgram(int lev, SymSet fsys) {

        int dx0, tx0, cx0;                  // 保留初始dx，tx和cx
        SymSet nxtlev = new SymSet(symnum);

        dx0 = dx;                           // 记录本层之前的数据量（以便恢复）
        dx = 3;
        tx0 = table.tx;                     // 记录本层名字的初始位置（以便恢复）
        table.get(table.tx).adr = interp.cx;

        interp.gen(Fct.JMP, 0, 0);

        if (sym == Symbol.programsym) {
            nextSym();
            if (sym == Symbol.ident) {
                nextSym();
                if (sym == Symbol.lbrace) {
                    nextSym();
                    while (sym == Symbol.structsym) {
                        parseTypeDef(lev+1, declbegsys);
                    }
                    while (sym == Symbol.funcsym) {
                        parseFuncDef(lev+1, declbegsys);
                    }
                    if (sym == Symbol.mainsym) {
                        nextSym();
                        if (sym == Symbol.lbrace) {
                            nextSym();
                            SymSet stmtFollow = new SymSet(symnum);
                            stmtFollow.set(Symbol.rbrace); // main's stmt_list ends with '}'
                            parseStmtList(stmtFollow);
                            if (sym == Symbol.rbrace) {
                                nextSym(); // Consume '}' of main block
                                if (sym == Symbol.rbrace) { // Consume '}' of program block
                                    nextSym();
                                    if (sym != Symbol.eof) {
                                        Err.report(20); // End of file expected
                                    }
                                } else {
                                    Err.report(14); // "}" expected (for the outermost program block)
                                }
                            } else {
                                Err.report(14); // "}" expected (for the 'main' block)
                            }
                        } else {
                            Err.report(14); // "{" expected (for 'main' block)
                        }
                    } else {
                        Err.report(19); // "main" expected
                    }
                } else {
                    Err.report(14); // "{" expected (for program block)
                }
            } else {
                Err.report(2); // Identifier expected
            }
        } else {
            Err.report(1); // "program" expected
        }
    }

    public void parseTypeDef(int lev, SymSet fsys) {
        parseStructDef(lev, fsys);
    }

    public void parseStructDef(int lev, SymSet fsys) {
        if (sym == Symbol.structsym) {
            nextSym(); // 消费 "struct"
            if (sym == Symbol.ident) {
                String structName = lex.id; // 获取结构体名称
                table.enter(Objekt.struct, lev, 0); // 在符号表中注册结构体
                int structTx = table.tx; // 获取新条目的索引
                table.get(structTx).name = structName; // 设置名称
                table.get(structTx).members = new ArrayList<>(); // 初始化成员列表
                nextSym(); // 消费标识符
                if (sym == Symbol.lbrace) {
                    nextSym(); // 消费 "{"
                    while (sym == Symbol.letsym) { // 循环解析成员声明
                        parseMemberDeclare(structTx, fsys); // 解析单个成员
                        if (sym == Symbol.semicolon) {
                            nextSym(); // 消费 ";"
                        } else {
                            Err.report(10); // 分号缺失错误
                        }
                    }
                    if (sym == Symbol.rbrace) {
                        nextSym(); // 消费 "}"
                    } else {
                        Err.report(14); // "}" 缺失错误
                    }
                } else {
                    Err.report(14); // "{" 缺失错误
                }
            } else {
                Err.report(2); // 标识符缺失错误
            }
        } else {
            Err.report(40); // "struct" 缺失错误
        }
    }

    public void parseMemberDeclare(int structTx, SymSet fsys) {
        if (sym == Symbol.letsym) {
            nextSym();
            if (sym == Symbol.ident) {
                String memberName = lex.id;
                nextSym();
                Objekt memberKind = Objekt.variable;
                int memberSize = 1;
                if (sym == Symbol.lbracket) {
                    nextSym();
                    if (sym == Symbol.number) {
                        memberKind = Objekt.array;
                        memberSize = lex.num;
                        nextSym();
                        if (sym == Symbol.rbracket) {
                            nextSym();
                        } else {
                            Err.report(28); // "]" expected
                        }
                    } else {
                        Err.report(4); // Number expected
                    }
                }
                // Create a new Item for the member
                Table.Item memberItem = new Table.Item();
                memberItem.name = memberName;
                memberItem.kind = memberKind;
                memberItem.size = memberSize;
                memberItem.level = 0; // Members are at level 0
                // Calculate the offset: current size of the struct
                int offset = table.get(structTx).size;
                memberItem.adr = offset;
                // Add the member to the struct's members list
                table.get(structTx).members.add(memberItem);
                // Update the struct's total size
                table.get(structTx).size += memberSize;
            } else {
                Err.report(2); // Identifier expected
            }
        } else {
            Err.report(42); // "let" expected
        }
    }

    public void parseFuncDef(int lev, SymSet fsys) {
        if (sym == Symbol.funcsym) {
            nextSym(); // Consume "func"
            if (sym == Symbol.ident) {
                String funcName = lex.id; // Get function name
                table.enter(Objekt.function, lev, 0); // Register function in symbol table
                int funcTx = table.tx; // Get index of new entry
                table.get(funcTx).name = funcName; // Set name
                nextSym(); // Consume identifier
                if (sym == Symbol.lparen) {
                    nextSym(); // Consume "("
                    if (sym != Symbol.rparen) {
                        parseParamList(funcTx, fsys); // Parse parameter list
                    }
                    if (sym == Symbol.rparen) {
                        nextSym(); // Consume ")"
                        if (sym == Symbol.lbrace) {
                            nextSym(); // Consume "{"
                            SymSet stmtFollow = new SymSet(symnum);
                            stmtFollow.set(Symbol.rbrace);
                            stmtFollow.set(Symbol.returnsym);
                            parseStmtList(stmtFollow); // Parse statement list
                            if (sym == Symbol.returnsym) {
                                nextSym(); // Consume "return"
                                parseExpr(fsys); // Parse return expression
                                if (sym == Symbol.semicolon) {
                                    nextSym(); // Consume ";"
                                } else {
                                    Err.report(10); // Missing semicolon
                                }
                            } else {
                                Err.report(23); // Missing "return"
                            }
                            if (sym == Symbol.rbrace) {
                                nextSym(); // Consume "}"
                            } else {
                                Err.report(14); // Missing "}"
                            }
                        } else {
                            Err.report(14); // Missing "{"
                        }
                    } else {
                        Err.report(15); // Missing ")"
                    }
                } else {
                    Err.report(15); // Missing "("
                }
            } else {
                Err.report(2); // Missing identifier
            }
        } else {
            Err.report(41); // Missing "func"
        }
    }

    // Placeholder for parseParamList
    // You would implement this based on your EBNF: <param_list> = <ident> { "," <ident> }
    public void parseParamList(int funcTx, SymSet fsys) {
        if (sym == Symbol.ident) {
            table.enter(Objekt.variable, L25.levmax, dx++); // Assuming parameters are variables
            nextSym();
            while (sym == Symbol.comma) {
                nextSym();
                if (sym == Symbol.ident) {
                    table.enter(Objekt.variable, L25.levmax, dx++); // Assuming parameters are variables
                    nextSym();
                } else {
                    Err.report(2); // Identifier expected
                }
            }
        }
        // Test for follow set, if necessary
        test(fsys, declbegsys, 6); // Example error code
    }

    // Placeholder for parseExpr
    // You would implement this based on your EBNF: <expr> = [ "+" | "-" ] <term> { ("+" | "-") <term> }
    public void parseExpr(SymSet fsys) {
        // For simplicity, let's just consume a number or ident for now.
        // A full implementation would involve parsing terms, factors, and operators.
        if (sym == Symbol.plus || sym == Symbol.minus) {
            nextSym();
        }

        SymSet nxtlevForTerm = new SymSet(symnum);
        nxtlevForTerm.or(fsys);
        nxtlevForTerm.set(Symbol.plus);
        nxtlevForTerm.set(Symbol.minus);
        parseTerm(fsys);
        while (sym == Symbol.plus || sym == Symbol.minus) {
            nextSym();
            parseTerm(nxtlevForTerm);
        }
        // Test for follow set, if necessary
        test(fsys, declbegsys, 6); // Example error code
    }

    // Placeholder for parseTerm
    // You would implement this based on your EBNF: <term> = <factor> { ("*" | "/") <factor> }
    public void parseTerm(SymSet fsys) {
        // For simplicity, let's just consume a number or ident for now.
        SymSet nxtlevForFactor = new SymSet(symnum);
        nxtlevForFactor.or(fsys);
        nxtlevForFactor.set(Symbol.times);
        nxtlevForFactor.set(Symbol.slash);
        parseFactor(nxtlevForFactor);
        while (sym == Symbol.times || sym == Symbol.slash) {
            nextSym();
            parseFactor(nxtlevForFactor);
        }
        // Test for follow set, if necessary
        test(fsys, declbegsys, 6); // Example error code
    }

    // Placeholder for parseFactor
    // You would implement this based on your EBNF: <factor> = <ident> | <number> | "(" <expr> ")" | <func_call> | <lvalue>
    public void parseFactor(SymSet fsys) {
        // For simplicity, let's just consume a number or ident for now.
        if (sym == Symbol.ident || sym == Symbol.number) {
            nextSym();
        } else if (sym == Symbol.lparen) {
            nextSym();
            parseExpr(fsys); // Recursive call for parenthesized expression
            if (sym == Symbol.rparen) {
                nextSym();
            } else {
                Err.report(15); // Missing ')'
            }
        } else {
            // Handle func_call or lvalue
            // For now, assume it's an error if not ident, number, or lparen
            Err.report(21); // Invalid factor
            // Emergency recovery
            SymSet s1 = new SymSet(symnum);
            s1.or(fsys);
            s1.or(facbegsys);
            test(facbegsys, s1, 6); // Error code for invalid factor
        }
        // Test for follow set, if necessary
//        test(fsys, declbegsys, 6); // Example error code
        // The test at the end should use the fsys passed to it.
        test(fsys, facbegsys, 6); // Test for follow set of factor
    }


    /**
     * 解析 <stmt_list> [cite: 4]
     * <stmt_list> = <stmt> ";" { <stmt> ";" } [cite: 4]
     *
     * @param fsys 后跟符号集
     */
    public void parseStmtList(SymSet fsys) {
        // 创建一个新的后跟符号集，用于解析单个语句
        SymSet nxtlev = new SymSet(symnum);
        nxtlev.or(fsys); // 继承父级的后跟符号
        nxtlev.set(Symbol.semicolon); // 语句后必须有分号 [cite: 4]

        do {
            parseStatement(nxtlev, 0); // Parse a single statement

            if (sym == Symbol.semicolon) {
                nextSym(); // Consume the semicolon
            } else {
                Err.report(10); // Missing semicolon
                // Attempt to recover: skip to the next statement beginning or end of list
                // This 'test' helps in recovery if the semicolon is missing.
                SymSet recoverySet = new SymSet(symnum);
                recoverySet.or(fsys);
                recoverySet.or(statbegsys);
                test(recoverySet, statbegsys, 6); // Error: Missing semicolon or invalid statement
            }
            // Continue looping if the current symbol is a valid start for another statement
            // AND it's not one of the symbols that should terminate the stmt_list (from fsys).
        } while (statbegsys.get(sym) && !fsys.get(sym));

        // 测试当前符号是否在fysy中，如果不在则报告错误并进行恢复
        test(fsys, statbegsys, 7); // Error: Invalid statement or missing end of statement list
    }

    /**
     * 解析 <stmt> [cite: 5]
     * <stmt> = <declare_stmt> | <assign_stmt> | <if_stmt> | <while_stmt> | <input_stmt> | <output_stmt> | <func_call> [cite: 5]
     *
     * @param fsys 后跟符号集
     * @param lev  当前层次
     */
    public void parseStatement(SymSet fsys, int lev) {
        if (statbegsys.get(sym)) { // Current symbol is in the FIRST set of <stmt>
            if (sym == Symbol.letsym) { // <declare_stmt> [cite: 6]
                parseDeclareStmt(lev, fsys);
            } else if (sym == Symbol.ident) { // Could be <assign_stmt> or <func_call> [cite: 5]
                // Need to distinguish between assign_stmt and func_call based on next token
                // For now, let's assume it's an assign_stmt if followed by becomes, otherwise func_call.
                // A more robust solution might require lookahead or a different parsing strategy.
                int pos = table.position(lex.id);
                if (pos == 0) { // Identifier not found
                    Err.report(11); // Undeclared identifier
                    nextSym(); // Consume the unknown identifier for recovery
                }
                nextSym(); // Consume the identifier
                if (sym == Symbol.becomes || sym == Symbol.lbracket || sym == Symbol.period) { // <assign_stmt> [cite: 8] (lbracket for array, period for struct member)
                    // If it's an lvalue, then it's an assignment.
                    // This is a simplified check, a full implementation would need to parse the lvalue more deeply.
                    parseAssignStmt(lev, fsys);
                } else if (sym == Symbol.lparen) { // <func_call> [cite: 5]
                    parseFuncCall(lev, fsys);
                } else {
                    Err.report(13); // Invalid statement starting with identifier
                    // Attempt recovery: skip until a known symbol or fsys
                    SymSet s1 = new SymSet(symnum);
                    s1.or(fsys);
                    s1.or(statbegsys);
                    test(s1, new SymSet(symnum), 6); // Error in statement
                }
            } else if (sym == Symbol.ifsym) { // <if_stmt> [cite: 5]
                parseIfStmt(lev, fsys);
            } else if (sym == Symbol.whilesym) { // <while_stmt> [cite: 5]
                parseWhileStmt(lev, fsys);
            } else if (sym == Symbol.inputsym) { // <input_stmt> [cite: 5]
                parseInputStmt(lev, fsys);
            } else if (sym == Symbol.outputsym) { // <output_stmt> [cite: 5]
                parseOutputStmt(lev, fsys);
            } else if (sym == Symbol.returnsym) { // <return_stmt>
                // Although not explicitly listed in <stmt> for L25 EBNF,
                // it is part of <func_def> and might be handled here.
                // For now, let's assume it's part of func def, so this branch might not be strictly needed for general stmt.
                // However, if return can appear as a standalone stmt in stmt_list, then uncomment.
                // parseReturnStmt(lev, fsys);
                Err.report(24); // Return statement not expected here
                nextSym(); // Consume return symbol for recovery
            } else {
                Err.report(8); // Invalid statement start
                // Attempt recovery: skip until a known symbol or fsys
                SymSet s1 = new SymSet(symnum);
                s1.or(fsys);
                s1.or(statbegsys);
                test(s1, new SymSet(symnum), 6); // Error in statement
            }
        } else {
            Err.report(8); // Invalid statement start
            // Attempt recovery: skip until a known symbol or fsys
            SymSet s1 = new SymSet(symnum);
            s1.or(fsys);
            s1.or(statbegsys);
            test(s1, new SymSet(symnum), 6); // Error in statement
        }
        // No explicit test for fsys here, as it's handled by the caller (parseStmtList) expecting a semicolon.
        // Individual statement parsing functions should ensure they consume their parts.
    }

    // Placeholder for parseDeclareStmt
    // <declare_stmt> = "let" <ident> [ "[" <number> "]" ] [ "=" <expr> ] | "let" <ident> <ident> [ "=" <struct_init> ] [cite: 6]
    public void parseDeclareStmt(int lev, SymSet fsys) {
        if (sym == Symbol.letsym) {
            nextSym();
            if (sym == Symbol.ident) {
                String varName = lex.id;
                nextSym();
                if (sym == Symbol.lbracket) { // Array declaration [cite: 6]
                    nextSym();
                    if (sym == Symbol.number) {
                        int arraySize = lex.num;
                        table.enter(Objekt.array, lev, dx);
                        table.get(table.tx).size = arraySize;
                        dx += arraySize;
                        nextSym();
                        if (sym == Symbol.rbracket) {
                            nextSym();
                        } else {
                            Err.report(28); // "]" expected
                        }
                    } else {
                        Err.report(4); // Number expected for array size
                    }
                } else if (sym == Symbol.ident) { // Struct declaration: let struct_name var_name [cite: 6]
                    // The first ident is the struct type, the second is the variable name
                    String structTypeName = varName; // The first ident is actually the type
                    varName = lex.id; // The second ident is the variable name
                    nextSym();

                    int structTypePos = table.position(structTypeName);
                    if (structTypePos == 0 || table.get(structTypePos).kind != Objekt.struct) {
                        Err.report(43); // Undefined struct type
                    } else {
                        table.enter(Objekt.struct, lev, dx); // Enter struct variable
                        table.get(table.tx).size = table.get(structTypePos).size; // Copy size from struct definition
                        dx += table.get(structTypePos).size; // Allocate space for struct instance
                        table.get(table.tx).name = varName; // Set the variable name
                        table.get(table.tx).members = table.get(structTypePos).members; // Link to struct definition's members
                    }

                    if (sym == Symbol.becomes) { // Optional initialization [cite: 6]
                        nextSym();
                        parseStructInit(lev, fsys);
                    }
                } else { // Simple variable declaration [cite: 6]
                    table.enter(Objekt.variable, lev, dx++); // Increment dx for variable
                }

                if (sym == Symbol.becomes) { // Optional assignment [cite: 6]
                    nextSym();
                    parseExpr(fsys); // Parse the expression for initialization
                }
            } else {
                Err.report(2); // Identifier expected
            }
        } else {
            Err.report(42); // "let" expected
        }
        test(fsys, statbegsys, 6); // Test for follow set of declare_stmt
    }

    // Placeholder for parseAssignStmt
    // <assign_stmt> = <lvalue> "=" <expr> [cite: 3]
    public void parseAssignStmt(int lev, SymSet fsys) {
        parseLValue(lev, fsys); // Parse the left-hand side [cite: 8]
        if (sym == Symbol.becomes) {
            nextSym();
            parseExpr(fsys); // Parse the expression for assignment
        } else {
            Err.report(12); // Missing ":=" or "=" (depending on convention, assuming becomes here)
        }
        test(fsys, statbegsys, 6); // Test for follow set of assign_stmt
    }

    // Placeholder for parseIfStmt
    // <if_stmt> = "if" "(" <bool_expr> ")" "{" <stmt_list> "}" [ "else" "{" <stmt_list> "}" ] [cite: 3]
    public void parseIfStmt(int lev, SymSet fsys) {
        if (sym == Symbol.ifsym) {
            nextSym();
            if (sym == Symbol.lparen) {
                nextSym();
                parseBoolExpr(fsys); // Parse boolean expression
                if (sym == Symbol.rparen) {
                    nextSym();
                    if (sym == Symbol.lbrace) {
                        nextSym();
                        SymSet stmtListFollow = new SymSet(symnum);
                        stmtListFollow.or(fsys);
                        stmtListFollow.set(Symbol.rbrace);
                        stmtListFollow.set(Symbol.elsesym); // 'else' can follow if statement
                        parseStmtList(stmtListFollow); // Parse statement list in if block
                        if (sym == Symbol.rbrace) {
                            nextSym();
                            if (sym == Symbol.elsesym) { // Optional else block [cite: 3]
                                nextSym();
                                if (sym == Symbol.lbrace) {
                                    nextSym();
                                    parseStmtList(fsys); // Parse statement list in else block
                                    if (sym == Symbol.rbrace) {
                                        nextSym();
                                    } else {
                                        Err.report(14); // Missing "}"
                                    }
                                } else {
                                    Err.report(14); // Missing "{" for else
                                }
                            }
                        } else {
                            Err.report(14); // Missing "}" for if
                        }
                    } else {
                        Err.report(14); // Missing "{" for if
                    }
                } else {
                    Err.report(15); // Missing ")"
                }
            } else {
                Err.report(15); // Missing "("
            }
        }
        test(fsys, statbegsys, 6); // Test for follow set of if_stmt
    }

    // Placeholder for parseWhileStmt
    // <while_stmt> = "while" "(" <bool_expr> ")" "{" <stmt_list> "}" [cite: 3]
    public void parseWhileStmt(int lev, SymSet fsys) {
        if (sym == Symbol.whilesym) {
            nextSym();
            if (sym == Symbol.lparen) {
                nextSym();
                parseBoolExpr(fsys); // Parse boolean expression
                if (sym == Symbol.rparen) {
                    nextSym();
                    if (sym == Symbol.lbrace) {
                        nextSym();
                        SymSet stmtListFollow = new SymSet(symnum);
                        stmtListFollow.or(fsys);
                        stmtListFollow.set(Symbol.rbrace);
                        parseStmtList(stmtListFollow); // Parse statement list in while block
                        if (sym == Symbol.rbrace) {
                            nextSym();
                        } else {
                            Err.report(14); // Missing "}"
                        }
                    } else {
                        Err.report(14); // Missing "{"
                    }
                } else {
                    Err.report(15); // Missing ")"
                }
            } else {
                Err.report(15); // Missing "("
            }
        }
        test(fsys, statbegsys, 6); // Test for follow set of while_stmt
    }

    // Placeholder for parseInputStmt
    // <input_stmt> = "input" "(" <ident> { "," <ident> } ")" [cite: 3]
    public void parseInputStmt(int lev, SymSet fsys) {
        if (sym == Symbol.inputsym) {
            nextSym();
            if (sym == Symbol.lparen) {
                nextSym();
                if (sym == Symbol.ident) {
                    // Check if identifier is declared as variable or array (for simple input)
                    int pos = table.position(lex.id);
                    if (pos == 0) {
                        Err.report(11); // Undeclared identifier
                    } else if (table.get(pos).kind != Objekt.variable && table.get(pos).kind != Objekt.array) {
                        Err.report(22); // Input to non-variable/array
                    }
                    nextSym();
                    while (sym == Symbol.comma) {
                        nextSym();
                        if (sym == Symbol.ident) {
                            pos = table.position(lex.id);
                            if (pos == 0) {
                                Err.report(11); // Undeclared identifier
                            } else if (table.get(pos).kind != Objekt.variable && table.get(pos).kind != Objekt.array) {
                                Err.report(22); // Input to non-variable/array
                            }
                            nextSym();
                        } else {
                            Err.report(2); // Identifier expected
                        }
                    }
                    if (sym == Symbol.rparen) {
                        nextSym();
                    } else {
                        Err.report(15); // Missing ")"
                    }
                } else {
                    Err.report(2); // Identifier expected
                }
            } else {
                Err.report(15); // Missing "("
            }
        }
        test(fsys, statbegsys, 6); // Test for follow set of input_stmt
    }

    // Placeholder for parseOutputStmt
    // <output_stmt> = "output" "(" <expr> { "," <expr> } ")" [cite: 3]
    public void parseOutputStmt(int lev, SymSet fsys) {
        if (sym == Symbol.outputsym) {
            nextSym();
            if (sym == Symbol.lparen) {
                nextSym();
                parseExpr(fsys); // Parse the first expression
                while (sym == Symbol.comma) {
                    nextSym();
                    parseExpr(fsys); // Parse subsequent expressions
                }
                if (sym == Symbol.rparen) {
                    nextSym();
                } else {
                    Err.report(15); // Missing ")"
                }
            } else {
                Err.report(15); // Missing "("
            }
        }
        test(fsys, statbegsys, 6); // Test for follow set of output_stmt
    }

    // Placeholder for parseFuncCall
    // <func_call> = <ident> "(" [ <arg_list> ] ")" [cite: 3]
    public void parseFuncCall(int lev, SymSet fsys) {
        if (sym == Symbol.ident) {
            int pos = table.position(lex.id);
            if (pos == 0) {
                Err.report(11); // Undeclared identifier
            } else if (table.get(pos).kind != Objekt.function) {
                Err.report(25); // Call to non-function
            }
            nextSym(); // Consume function name
            if (sym == Symbol.lparen) {
                nextSym();
                if (sym != Symbol.rparen) { // Check for empty arg list
                    parseArgList(fsys); // Parse argument list
                }
                if (sym == Symbol.rparen) {
                    nextSym();
                } else {
                    Err.report(15); // Missing ")"
                }
            } else {
                Err.report(15); // Missing "("
            }
        } else {
            Err.report(2); // Identifier (function name) expected
        }
        test(fsys, statbegsys, 6); // Test for follow set of func_call
    }

    // Placeholder for parseArgList
    // <arg_list> = <expr> { "," <expr> } [cite: 3]
    public void parseArgList(SymSet fsys) {
        parseExpr(fsys);
        while (sym == Symbol.comma) {
            nextSym();
            parseExpr(fsys);
        }
        // No explicit test for fsys here, as it's typically followed by rparen, handled by caller.
    }

    // Placeholder for parseBoolExpr
    // <bool_expr> = <expr> ("==" | "!=" | "<" | "<=" | ">" | ">=") <expr> [cite: 3]
    public void parseBoolExpr(SymSet fsys) {
        parseExpr(fsys); // First expression
        if (sym == Symbol.eql || sym == Symbol.neq || sym == Symbol.lss ||
                sym == Symbol.leq || sym == Symbol.gtr || sym == Symbol.geq) {
            nextSym(); // Consume relational operator
            parseExpr(fsys); // Second expression
        } else {
            Err.report(20); // Relational operator expected (Error code 20 is already for "End of file expected" in parseProgram, consider using a new error code)
            Err.report(44); // Relational operator expected
        }
        // No explicit test for fsys here, as it's typically followed by rparen, handled by caller.
    }

    // Placeholder for parseLValue
    // <lvalue> = <ident> [ "[" <expr> "]" ] | <ident> "." <ident> [cite: 8]
    public void parseLValue(int lev, SymSet fsys) {
        if (sym == Symbol.ident) {
            String varName = lex.id;
            int pos = table.position(varName);
            if (pos == 0) {
                Err.report(11); // Undeclared identifier
            }
            nextSym();
            if (sym == Symbol.lbracket) { // Array element access [cite: 8]
                if (pos != 0 && table.get(pos).kind != Objekt.array) {
                    Err.report(26); // Attempt to index non-array
                }
                nextSym();
                parseExpr(fsys); // Parse array index expression
                if (sym == Symbol.rbracket) {
                    nextSym();
                } else {
                    Err.report(28); // "]" expected
                }
            } else if (sym == Symbol.period) { // Struct member access [cite: 8]
                if (pos != 0 && table.get(pos).kind != Objekt.struct) {
                    Err.report(27); // Attempt to access member of non-struct
                }
                nextSym();
                if (sym == Symbol.ident) {
                    String memberName = lex.id;
                    if (pos != 0) {
                        // Check if memberName exists in the struct's members
                        boolean foundMember = false;
                        if (table.get(pos).members != null) {
                            for (Table.Item member : table.get(pos).members) {
                                if (member.name.equals(memberName)) {
                                    foundMember = true;
                                    break;
                                }
                            }
                        }
                        if (!foundMember) {
                            Err.report(45); // Undefined struct member
                        }
                    }
                    nextSym();
                } else {
                    Err.report(2); // Identifier (member name) expected
                }
            }
        } else {
            Err.report(2); // Identifier expected
        }
        // No explicit test for fsys here, as it's followed by '=' in assign_stmt, handled by caller.
    }

    // Placeholder for parseStructInit
    // <struct_init> = "{" [ <init_value> { "," <init_value> } ] "}" | <ident> [cite: 7]
    public void parseStructInit(int lev, SymSet fsys) {
        if (sym == Symbol.lbrace) {
            nextSym(); // Consume "{"
            if (sym != Symbol.rbrace) { // Not an empty initialization list
                parseInitValue(lev, fsys);
                while (sym == Symbol.comma) {
                    nextSym();
                    parseInitValue(lev, fsys);
                }
            }
            if (sym == Symbol.rbrace) {
                nextSym(); // Consume "}"
            } else {
                Err.report(14); // "}" expected
            }
        } else if (sym == Symbol.ident) { // Initialization from another struct instance [cite: 7]
            int pos = table.position(lex.id);
            if (pos == 0) {
                Err.report(11); // Undeclared identifier
            } else if (table.get(pos).kind != Objekt.struct) {
                Err.report(46); // Expected struct instance for initialization
            }
            nextSym();
        } else {
            Err.report(47); // Invalid struct initialization
        }
        // Test for follow set, if necessary (e.g., semicolon after declaration)
        test(fsys, statbegsys, 6);
    }

    // Placeholder for parseInitValue
    // <init_value> = <expr> | "{" [ <expr> { "," <expr> } ] "}" [cite: 7]
    public void parseInitValue(int lev, SymSet fsys) {
        if (facbegsys.get(sym) || sym == Symbol.plus || sym == Symbol.minus) { // If it starts like an expression [cite: 7]
            parseExpr(fsys);
        } else if (sym == Symbol.lbrace) { // Nested initialization list [cite: 7]
            nextSym(); // Consume "{"
            if (sym != Symbol.rbrace) { // Not an empty nested list
                parseExpr(fsys);
                while (sym == Symbol.comma) {
                    nextSym();
                    parseExpr(fsys);
                }
            }
            if (sym == Symbol.rbrace) {
                nextSym(); // Consume "}"
            } else {
                Err.report(14); // "}" expected
            }
        } else {
            Err.report(48); // Invalid initialization value
        }
        // Test for follow set (e.g., comma or '}')
        SymSet nxtlev = new SymSet(symnum);
        nxtlev.or(fsys);
        nxtlev.set(Symbol.comma);
        nxtlev.set(Symbol.rbrace);
        test(nxtlev, facbegsys, 6);
    }

}
